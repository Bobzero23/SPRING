SET UP
+ Start a new Maven Project
+ Put the dependency of IoC Container of your choice (Context Application) you can find it in maven webpage
Then you're ready to go.

IOC(INVERSION OF CONTROL)
Software Design Principle, instead of a programmer creating the objects the framework creates for them.

LOOSE COUPLING
It means each class and object is independent and the less classes have knowledge about other class the loose they are.

BEAN
A plain Java class which is maintained by Spring Framework.

IoC CONTAINER
It is the container responsible for life time of beans with the help of annotations we make or the xml configs and also
injects the required dependencies.

TYPES OF IoC CONTAINERS
+ Bean Factory
+ Context Application

CONTEXT
Memory location of the web application where all the bean's information and dependencies are being maintained.

SpEL(SPRING EXPRESSION LANGUAGE)
The Strong expression language for querying and manipulating object graph at runtime like setting and getting
property values.

PROJECT CONFIG CLASS
Is the class which has definitions of beans with the annotation of @Configuration

** CHECK EXAMPLE1

NO UNIQUE BEAN DEFINITION EXCEPTION
This happens when you have call the method get bean from the data type which has multiple beans and without specifying
which bean exactly you want and to avoid it, you can pass two parameter to the get bean method to specify the bean name
also you can use the @Primary

@COMPONENT
Instead of creating bean of the class inside the ProjConfig Class we simply use this annotation and we wont have to use
bean while creating method of the type of this class, Spring will handle the rest, And if you gonna use this then you
will have to put the @ComponentScan(basePackages = "NameOfThePackageWhichHasTheComponentAnnotation")


+ BEAN NAMES ARE NORMALLY NOUN AND NOT VERBS
+ YOU CAN NOT CREATE A BEAN USING AN INTERFACE, ONLY CLASSES.

STEREOTYPE ANNOTATION
+ @Component -> It is the base for other annotation
+ @Service -> In this class we put Business logics and we can make external API's
+ @Repository -> Classes for the database
+ @Controller -> Used in Spring MVC to redirect the html page

@PostConstruct ANNOTATION
We use this above the method to gain the control when we use the @Component above the class and inside the method with
@PostConstruct Annotation we use the keyword this which we refer to the bean which is going to be created.

@PreDestroy ANNOTATION
We use this above the method which will work right after the bean is destroyed and sometimes when we are working with
database, nowadays Spring takes care of everything but most of the times we use it when there is context.close() and
it is also used when there are some cleaning which must be done before clearing the bean.

RegisterBean()
Helps us to create bean according to the given condition

BEANS WITH XML
1. In this section we created the bean using xml, check the xml file in resources
2. Here the xml file acts as the Pojo class
3. In the main method we have to use another way of creating object of IoC Container go check it
and there you pass the name of the xml file folder you created

DI (DEPENDENCY INJECTION)
Is Like making the framework knows that a particular something is belonging or depending to a particular person.

AUTOWIRED
1. Can be used on top of the setter, constructor or class fields
2. This is an example of Dependency Injection (Dynamic)
3. We initialized the component annotation on top of the pojo classes to make things easier
4. This method is not recommended because you can't initialize a autowired field as final but still most
   developers almost 99% of developers are using this because it is easy to use ..
5. Use this method with annotation on the constructor that's the better way because it allows finals fields

AUTO WIRING DEEP DIVING
1. When we use @autowired with constructor we might have more than one pojo class and we might have more than one
   beans and in case sometimes they might have the same name, which lead us to NoUnique error but as we know we use
   the @primary annotation we might get rid of that error, if we don't have it there are more steps which Spring follows
   to check before giving the error check the codes.

QUALIFIER ANNOTATION
1. We use this annotation when we use @autowired annotation and when we want to get a bean using their name so
   we use this annotation to pass the name.

CIRCULAR DEPENDENCY
1. This happens when a programmer create two @autowired annotation in both two pojo class in that case the Spring
   will not know which bean should be first created and both bean will wait for other bean to be created, and
   such a scenario will display a UnsatisfiedDependencyException, and hey there is no solution for it you gonna
   have to avoid this thing from the beginning hhhh.

5 TYPES OF SCOPE IN BEAN -> @Scope(BeanDefinition.SCOPE_PROTOTYPE)
1. Singleton -> Default Scope in Spring also commonly used
2. Prototype
3. Request
4. Session
5. Application

SINGLETON BEAN SCOPE
1. This one creates only one a object for all application, even you create another object that object will refer to this

RACE CONDITION
This happens when two threads trying to reach the same shared variable

EAGER AND LAZY INITIALIZATION
This concept is only valid in SINGLETON
1. Eager is when you run the Spring program all the beans are being created first before everything else
2. Lazy is when the bean is being created at the time you want to use a particular bean

PROTOTYPE BEAN SCOPE
This one creates a new object everytime a bean is called or created

Note: Do not create a bean on Pojo class if they only have getters and setters, they shall have business logic at least.

AOP (ASPECT ORIENTED PROGRAMMING) -> the point is to to move all the non-functional to one class which we can call it
    aspects so that it will be easier to maintain.. We can normally do this

+ WE SHOULDN'T CREATE BEANS FOR THE JAVA CLASSES WHICH ONLY HAVE GETTERS AND SETTER UNLESS THEY HAVE BUSINESS LOGIC,
  WE SHOULD PUT THIS TYPE OF CLASSES IN MODEL PACKAGE


ASPECT
1. A piece of code you want to execute when you call your business logic methods

* ADD LIBRARIES TO USE THE AOP -> dependency

AOP JARGON'S
1. WHAT -> Aspect -> what code or logic we want to execute
2. WHEN  -> Advice -> when we want to execute it
3. WHICH -> Pointcut -> which method we wanna use with it
Point cut -> method call
Target object -> the bean class

TYPICAL SCENARIO OF AOP IMPLEMENTATION
A developer wants some logic(Aspect) to be executed before(Advice) each execution(JoinPoint) of method
playMusic()(PointCut) present inside the bean VehicleServices(TargetObject)

WEAVING INSIDE AOP
When we implement AOP inside our app, Spring intercepts each method according to the logic in our Aspect. Instead of
giving the reference of a method it gives a proxy object that will manage each call.

CONFIGURING ADVICES INSIDE AOP
1. We can use the AspectJ pointcut to tell the spring which methods need to be intercepted
2. We need to enable the Aspect Proxy on our configuration class
3. Creating a bean class which will also be the Aspect class for the logger
4. Inside the Aspect Class we create a method which will have aspect logic
5. To tell spring which method to intercept we use aspect advices such as @Around @Before and configuring it.

Type of advices in Spring AOP
@Before -> runs before the actual java method invocation
@AfterReturning -> runs after the program finish the execution successfully
@AfterThrowing -> runs when something wrong happened like telling the user that something happened
@After -> runs after but accordingly
@Around -> Combination of @After and @Before this one is very powerful

TO WORK WITH AOP YOU MUST USE @EnableAspectJAutoProxy on the project configuration class to enable the features
and we must first inject the libraries of AOP in our Pom.xml file

* Aspect class shall have three annotations
+ Aspect
+ Component
+ Advice annotation

* Since we all know that @Around annotation is the combination of @Before and @After so that we we are writing our
  aspect logic in our join point we have to use the jointPoint.Proceed() method to tell the spring that we are done
  with our before logic so it can proceed with the target class and the it will do the after logic

* I think that the targeted class shall only have to initiate the Logger object to be ready to go. No I also think
  that it works because we have the aspect annotation

* I accepted ProceedingJoinPoint as a input parameter because when we use around there will be before and after

* If we have more than one aspect we can use order() and pass the number to tell Spring which aspect to start with

******************************* THIS IS ALL FOR SPRING CORE, CONGRATULATIONS!! ***********************************

+++++++++++++++++++++++++++++++++++++++++++++++++++++ SPRING MVC  ++++++++++++++++++++++++++++++++++++++++++++++++++
* Java actually only use objects but fronted request always uses http protocols so how does Java understands that,
  that is where the servletContainer come to picture it changes the protocols to objects I guess, and before Spring
  the developer had to create each servlet by himself. Spring has dispatcherServlet which deal with every request
  coming from the client and we have to do a very minor work and the rest is on Spring.

SPRING BOOT IMPORTANT FEATURES
+ SpringBoot Starters
+ SpringBoot AutoConfiguration
+ SpringBoot Actuators and DevTools

CREATING A WEB APP
1. Go to start.spring.io there will start creating spring boot skeleton

RUNNING A WEB APP
1. As we run a normal java class we need a class with a main. It is same to spring boot but the only difference is
   you will have to put this annotation @SpringBootApplication and whenever you run SpringBoot app the Spring
   Framework will look for this annotation and treat this class as a main class.

HELL WORD WEB APP
1. Start with creating the html file in the static folder and then write whatever you wanna see in the browser
2. By default SpringBoot looks for static folders so you don't have to tell the location, but you have to tell Spring
   which html file shall it redirect and do that by creating the controller class and write the java code..
3. In that class mention the @Controller at the top of the class and create a method with a @RequestMapping
   which will hold the url of the html to be provoked and that method shall return STRING then return the name
   of the html file you want to provoke as a returning value.

STATIC FOLDER IN RESOURCES
There is where you put your CSS and JS OR IMAGES ETC.

TEMPLATE FOLDER IN RESOURCES
There is where you put your html folders if you are using thymeleaf

TO INVOKE THE WEB
1. We need a controller class which will tell the web that we invoking the web from a particular html.
2. Inside that class we use the @Controller annotation
3. Inside the controller class you need to write the method to tell that anyone who opens e.g /home should be redirected
   to e.g home.html and for that we going to use the @RequestMapping("/home") annotation

APPLICATION.PROPERTIES FOLDER
1. Is where you should go if you wanna make any configuration about SpringBoot by yourself

CHANGING THE SERVER PORT
1. Go to application.properties folder and write -> server.port = 8081

CHANGING THE CONTEXT PATH
1. Go to application.properties folder and write -> server.servlet.context-path = /demonstration

RANDOM PORT NUMBER
1. Simple go to application.properties folder and write -> server.port = 0
    this will tell the spring that the programmer wants to start the server in a random ports each time
    it is helpful if you wanna run your web app in different instances

LOCAL HOST 8080
1. Using small configuration you can run your localhost without mentioning the /home, check the controller class
    @RequestMapping(value = {"", "/", "home"})

THYMELEAF
1. Modern server side template engine which provides a way for a developer to work frontend and backend, and let
   the developers to deploy their work on the single server
2. By working with Spring MVC, Thymeleaf generates the html and dynamic content based on the template we want
3. SpringResourceTemplateResolver is the one which converts the Thymeleaf code to html


HOW TO USE THYMELEAF
1. Create your html folder inside the template folder because thymeleaf is a template engine
2. then you need to import the namespace of the thymeleaf inside of a html file in the html tag
    after you do that your html will start using thymeleaf tags which start with th:
3. After doing that we gonna pass the Model interface and its object on the particular html controller file
    then we will be good to go
4. After passing the Model interface as a parameter in the particular html method then you use the model.addAttribute
    methods which accepts a variable and a value inside it and both are in quotes "".

DISPLAYING DYNAMIC CONTENT
1. We gonna be able to do this with the help of Thyme leaf by creating a html file inside the template and then
   in the controller class we need to pass MODEL interface and its object as method input parameter, this Model
   interface acts as a container while creating dynamic content using Thymeleaf
2. Using Model interface object we can use a method modelAttribute() to pass whatever is coming from our http request

DISABLING CACHE IN THYMELEAF
1. The changes you are making in template folders wont be shown even after you do rebuild unless you restart the server
2. This is why you wont have to restart the server everytime you make some change in you template you just build and
   then you are good to go
3. To do it go to the your properties.application and say spring.thymeleaf.cache = false
4. For more information go check the application properties app there are more details
   This is not for java codes so if you change java code you gonna have to restart the server

                                SPRING BOOT DEVTOOLS
1. This makes you just write java code and just build and you are good to go so inject the dependencies
2. This will also takes care of the caching

DOWNLOAD LIVERELOAD EXTENSION IN YOUR WEB BROWSER

MVC PATTERN
1. View -> html / JavaScript
2. Controller -> Acts like a brain tells Spring which business Logic shall be execute
3. Model ->

                                MVC (MODEL VIEW CONTROLLER)
1. The main objective is to achieve loose double coupling inside the web application we are building.

MVC ARCHITECTURE
1.Client send a request in a http format
2.The request goes to Servlet Container such as Tomcat, this convert the http request to the servlet request
    and sending the request to the dispatcher servlet
3.Dispatcher servlet only knows the path but it doesn't anything else like method or which controller and for
    that it goes and ask handler mapping like which controller and which method shall be invoked and it will
    finish the rest by visiting those controller and invoking the methods needed
4. Then the controller will return the view which shall be displayed to the client as a response like view.html
    but the dispatcher doesn't know about the views so it goes and ask View Resolver
5. View resolver will finish the view job and all return the view to the servlet dispatcher and again it sends back
    to the server and the server sends it back to the client

                                       WEBSITE PROJECT
1. Putting the HEADER and the FOOTER html code in different files
   but you will import the files of those two files code on their places in the home.html file

REDIRECTING A PARTICULAR LINK TO ANOTHER HTML PAGE USING THYMELEAF
th:href="@{/home}"

REDIRECTING A HTML FILE TO ANOTHER HTML FILE
<div th:replace="header :: header"></div>

             WEB CONFIG FILE
TO AVOID CREATING CONTROLLERS EVERYTIME
1. Create a package called webconfig
2. Create a pojo class which is going to handle all he controllers inside it
3. That class is going to implement the WebMvcConfigurer
4. That class will also have the @Configuration annotation
5. Inside that class you override a method called addViewControllers and that is
   how you are going to configure all the controllers just like that inside that method. For more info look at the code

@RequestMapping and @PostMapping
1. RequestMapping is like a generic annotation which accepts the method type as parameter if you mention it and if you not,
   it will accept any kind as default but PostMapping you don't have to pass any parameter of a method type because itself is
   self description

QUICK TIP:
sometimes the webpage doesn't reload automatically even after you used the devtools the thing is go to your LOCAL
maven file and delete the files found inside the target file and that will resolve this issue

GETTING THE MESSAGE FROM THE PAGE
1. Go to the particular html file controller which you are working with and create another method and pass the map too.
2. Create a method with value ModelAndView which takes @RequestParam for each value match in the html, please make sure
   the values matches I mean from UI and in the code you are writing

MODEL AND VIEW
This object is used when you want to take an input from the user and to tell the user than you received the input by like
maybe emptying the blanks or refreshing the page e.t.c ... also helps us to receive and send a view to the end user.

BREADCRUMB
Like when you click the Logo of the website then it refreshes the page or takes you to the homepage of Youtube

MODEL CLASS
Normally to avoid putting unnecessary codes inside the method we can create class which will act as input and that class
we have all the necessary inputs in its field and then inside the particular method you will put the class and the its
object as input and that is a better way of doing it..

SERVICE LAYER
Normally inside controller layer we do all the validations and after that we let the SERVICE layer to handle the info
and once service layer is done processing the information then next step would be the PERSISTENT layer or the DATA layer,
after you finish the service layer you gonna have to inject the class to the Controller layer you can do it using
constructor type of autoWiring.. and we do this injection so that we can use the method we created inside the Controller
class... in this class we only create the fields, getters and setters and to String method. make sure the fields matches
the frontend variables and names...

** WHEN YOU PASS THE FIELDS TO THE CONSTRUCTOR YOU ACTUALLY DON'T NEED A SETTER BECAUSE AS YOU CALL THE CONSTRUCTOR
   YOU WILL DEFINITELY HAVE TO PASS IN THE VALUES BUT YOU MIGHT NEED GETTERS.

SUBMITTING INFORMATION FROM A PAGE
Sometimes submitting information might become hard if there a lot of info input to take from the page so for that
there is a good approach for it by creating a package which will handle the models and there you create a pojo
which taking all the values and create their getters and setters and also the toString method.

NORMALLY INSIDE A PRODUCT WEB SERVICE YOU WILL BUILD YOUR LOGIC SUCH A WAY THAT INSIDE YOUR CONTROLLER LAYER YOU WILL DO
ALL YOUR PRIMARY VALIDATION AND AFTER FINISHING THAT YOU WILL GIVE THE JOB TO SERVICE LAYER AND AFTER SERVICE LAYER IS DONE
IT WILL SEND THE WORK TO THE PERSISTENCE LAYER AND TO MAKE ALL OF THESE WORK TOGETHER YOU GONNA HAVE TO DO THE AUTO WIRING
INJECTION IN CONTACT CONTROLLER EXAMPLE IF YOU WANNA WORK WITH CONTACT SERVICE, AFTER YOU DO THE INJECTION THE OBJECT OF
THE INJECTED CLASS WILL BE A BEAN WHICH WE CAN USE TO CALL ITS METHODS IN THE CERTAIN POJO

HOW TO SEND A DATA FROM BACKEND TO FRONTEND
1. We need a certain class which will define the structure of a particular html file, which we normally put in model package
    inside this pojo class you can have the field and constructor etc. check the codes
2. We need a controller class for mapping the structure here is where we do the wiring to and define our business logic

LOMBOK
This is a java library which provides some annotation to help a java programmer not to repeat some statements e.g getters
and setter, this library do create all the getter and setters in the background when we use its annotation
1.@Data is the common annotation which has all getters and setter and some more inside it.
2.@Slf4j is the annotation we use for Log instead of creating a log object use this and use the log object directly.
To start to use it, You gonna have to inject its dependencies

QUERY PARAM
1. This is mostly being used on the times of filtering the products like when you go to amazon searching for products and
there you can filter the price like only high or whatever that the usage of the query param
2. Between query param you use & sign to separate them and is a good practice to use to most three params
3. We normally use the @RequestParam annotation to to accept the query or accept the form data tha we're going to receive
5. We can also make the request param as MANDATORY or OPTIONAL, is like the user cant pass without filling the blank
6. To use them go to the particular link e.g holidays in footer.html and thymeleaf provides us an easy way to do this
7. After that you go the particular controller class and accepting the params
Note: Adding your params to Model attribute will give you an advantage to be able to send them back to the user
this are those links appear left bottom of the screen whenever hover around the cursor on the links in the website
8. To work with query parameters first find the in the html file where the particular page is invoked so we can put the
   query parameters like in the footer html page I where I invoke the holidays html page and you put the variables..
9. Then you go to that particular html controller class then you past the @request param and you put the then you decide
   if the request shall be required and then you mention the variables you put on the html page before just now.
10.Save the input that you are receiving the frontend url in the model.addAttribute() and the reason for that is so that
   we can send the same value back to the UI when it is needed.

DISPLAYING THE COLUMN ACCORDINGLY
Thymeleaf provides us the ability to make the html display according to the condition we put as we did in the
holidays.html to the rows and columns for the festival holidays e.g th:if="${festival} == true" and that's it.
In the method if you say that @RequestParam(Required = false ) you are making in optional

PATH PARAM vs QUERY PARAM
The primary difference between these two is, in QUERY param  the frontend application can send a request as URL

PATH PARAM
We use @PathVariable annotation to pass the name of the variable inside our method.
Note: There is no default value inside path param.
1. You need to catch the path of the variable by creating a variable inside your @getMapping in the controller file
2. Pass the same variable with the same name using @PathVariable inside method input parameter
3. After that you might want to write a logic to display the page accordingly because here is no boolean stuffs like
    inside query param check the holiday controller method for more understanding
Note: DO NOT FORGET TO MENTION THE '/' IN THE href LINKS IN THE SCRIPTS AND BOOTSTRAPS SO IT BECOME RECOGNIZABLE BY
 THE SPRING FRAMEWORK

VALIDATIONS
Actually this one is very important imagine you ask a user to enter a phone number and then they enter their name..

CLIENT SIDE VALIDATIONS
This is like you do the validations only in the client side like only in the html..
Go to a certain html field which you want to be must filled field and put required = "true"
Note: this kind of validation is not safe because someone can interact with your code in a browser and bypass it
      so it is better to have both client side and server side validations

VALIDATIONS WITH SPRING BOOT
1. Inject the dependencies of the library such us Hibernate
2. In each validation pojo class use @Valid annotation at the top
Note: There are two libraries in Java which provides these validations, Javax and Hibernate.
These validations we put in the Pojo classes in model package, check the contact Pojo class for more information
Note: We need to let the contact.html know that there is a validation.
3. To let the ui know we go to the particular ui controller class then we use the model object to be able to add the
   attribute and then we pass the new model class object there so to give the use new object each time the use the
   particular ui.
4. To let the ui know about the validations we go and pass the object using Thymeleaf in the form tag of ui
   and that is how you link them
5. For the same you need to create the link of the fields of the bean and variable in the ui

LETTING HTML KNOW ABOUT THE VALIDATION
1. Go to your particular controller Pojo class of the particular html class
2. Find the method which displaying the html file and there add a Model object in input method parameter
3. Use the model object to create a attribute and inside that attribute you need to send the object of contact
    That way, you will tell the thymeleaf that any validations performs should be performed according to that Pojo class
4. Go to the Contact.html and you need to build a relationship between the html file and and the Pojo class and for that,
   find the form where the inputs are coming from and mention this th:object="${contact}"
5. You also have to build a link between the field in a bean Contact class and the fields in the html file and for that,
    find the field where you put names in your html file and do this, remove the name and id's and id and add the thymeleaf
    like this  th:field="*{mobileNum}"
Note: Now whenever a user submitting a change in the html file action will perform, which goes to savaMessage method inside
      the contactController class there we need to make some changes inside the method input parameter
6. add the @Valid and @ModelAttribute("contact") to method input parameter before the Contact object which is inside the
    method input parameter, after the contact object put a coma and add Errors object so if there is any error identified
    our spring frame work will send the error to us and to the client maybe to the client only I don't remember.
Note: Here you have a big chance to make a mess this is kinda messy work because after you declare the errors object
        in the method input you might wanna make changes inside the method to get the errors which you gonna have to use
        log with some if statements and for that also you method needs to return String type because you are getting errors
        from the log and this is what you must do
7. Write an if statement to check if there is any errors, which if there is, you will catch them with a log object
8. Write a log to get the errors inside the if statement
9. Change the method return type to String
10. Return the html page as a String inside the if statement to display the errors to the client
11. Also redirect with String only not with Model type... this will redirect the new html page if there is no errors
Note: Check the ContactController for more understanding
13. And you should go to the Contact html file to display the errors which you are getting from the backend
    paste this on top of the form
        <ul>
                            <li class="alert alert-danger" role="alert"
                                th:each="error : ${#fields.errors('contact.*')}" th:text="${error}" />
        </ul>
Note: you also can build your own validations


                                               SPRING WEB SCOPES
SCOPES
When a bean is created with these scopes
1. @RequestScope -> every application you do in the web will result as an HTTP request
    so is like when a user make http request each time they will get a new bean for it..
    This one a user get only one bean whatever he does in the particular page
2. @SessionScope -> every application you do in the web will create instance of the Session until the session in invalidated
    like when the user cleaning the cache, not like @RequestScope this one does not restart a new bean each time the
    user send the http request
    This one a user get a new bean for each http request in the particular page
3. @ApplicationScope -> will create a single unique bean for your entire application, each user will get the same instance
    this one a is useful for tracking how many user a using the web coz it sends a new bean for only a new user other wise
    there will be only one bean for each user


USE CASES OF SCOPES

Note: Don't create large logic inside your constructor

@Request
1. Life time is very short
2. Takes a lot of memory
3. A lot of garbage collections happening
4. Use it to only sensitive
Note: So don't use it when you need it..

@Session
1. Not commonly created
2. Have long life
3. Good to store information and use the same information according to the that information along the whole page
Note: Don't store many info like image etc.

@Application
1. Created only once and the same bean will be use with all users, this is like Singleton
2. Avoid the Race condition just like in Singleton, make it for mutable only
Note: There is case where the Singleton and Application acts different, like when you define Multiple Application Context
      your Singleton will have instance for each application where in the Application will have only one only one instance
3. Also this is useful like when you wanna mention total number of visitor of the website

                                    SPRING SECURITY
Focus on securities and so many features to protect your web application by making a small configuration

                DIFFERENCE BETWEEN AUTHENTICATION AND AUTHORIZATION
AUTHENTICATION                                          AUTHORIZATION
1.Identifying who is the user                          1.After identification you can access stuffs that related to you
2.Happens before authorization                         2.Can't happen before the authentication
3.401 error if authentication fails                    3.403 if authorization fails

IMPLEMENTATION - INJECTION
1. Inject the dependencies -> Just by injecting dependency Spring security will bring the log in without you do anything
Note: As default the Spring will create the log in page and as default the log in user name is user and password is
      is generally in the console where you started the project, I think it changes each time you restart the project

CONFIGURING USERNAME AND PASSWORD USING APPLICATION PROPERTY
Go to the Application properties and write these
   spring.security.user.name = Bobzero
   spring.security.user.password = 1234
Note: This is not recommended because you might have so many users

PERMITTING / ALLOWING ALL THE PAGE TO BE ACCESSIBLE PUBLICLY
1. Create a class which will have the configuration annotation
2. This class will extend the WebSecurityConfigurerAdapter
3. Also this class shall override the configure method which accepts HttpSecurity as a method parameter

formLogin() -> used for supporting username and password through an html form
httpBasic() -> used for supporting username and password to be send inside an http header like when someone is
trying to invoke my rest APIs
anyRequest() -> for any Request in the website or any API

Note: Also you can write your conditions in if statement like in which condition you want your website to be accessible
      with a password and so on..

DENYING ALL THE PAGE TO BE ACCESSIBLE
...check the code for more information
This denies even if the user is valid user

PERMITTING ALL AND DENYING ALL
1. Create a class for configuration and use the @Configuration
2. Create a bean of the Interface SecurityFilterChain and then pass in the HttpSecurity class and the object inside the
   input parameters then throw Exceptions and use the the object of the HttpSecurity class to PermitAll or DenyAll

Note: Normally you can use permitAll() or denyAll() on the top of whatever the case you want  and most of the times it is
      being used in the CSS/JS/IMAGES/Rest API files

COSTUME SECURITY CONFIGURATION
1. Instead of using anyRequest() you will configure security page by page... check the code for more information
2. Use authenticated() to only allow the valid users to access a particular page

CSRF
Is when a hacker tries to take your authentication token and try to mimic like you then send the request to backend
Thymeleaf handles the CSRF by defaults but if you don't use thyme leaf and use normal html you will get un error
while trying to submit something to the backend.. and that is when your SpringBoot stops your get and post request
to avoid the CSRF attack.. and if you are not handling the Spring will send the 403 error..

MATCHER METHODS
1. mvcMatcher -> Better if you are using Spring MVC
2. antMatcher -> If you are not working with Spring MVC or if you are working with Rest API, less secure tho
3. regexMatcher
Note: You can work with all of them in the same project tho


IN MEMORY AUTHENTICATION
We can provide authentication to the users using a method called InMemoryUserDetailsManager

** HAD A PROBLEM WHILE TRYING TO ACCESS THE LOCAL HOST WAS DENYING BECAUSE I DIDN'T KNOW THAT EVEN IT SHOULD BE /HOME

defaultSuccessUrl("/")
Telling spring what should happen if a particular page is authenticated successfully

failureUrl("/")
Telling Spring what shall happen if the particular page is authenticated without success

invalidateHttpSession(True)
invalidating the session like after the user has successfully logged out


Authentication auth = SecurityContextHolder.getContext().getAuthentication();
Using this we can get the current Authentication details

EXCEPTION HANDLING
This is very useful so that we can provide our own error message according to the end user and Spring provides some
annotations to help us do this.

@ControllerAdvice @ExceptionHandler
1. The class with this annotation will act as intercept globally among all your class and will handle the errors
2. For the class which shall be handling their errors you will write a method with @ExceptionHandler on top and you
   can write you own logic accordingly
Note: You can use @ExceptionHandler inside a particular Controller class but if you write the same annotation inside
the ControllerAdvice it will be globally working

DEEP DIVING TO CSRF (CROSS SITE REQUEST FORGERY)
1. Is like the hacker takes your token of your website and tries to use as you
CHECK THIS SUBJECT AGAIN BECAUSE YOU DIDNT IMPLEMENT

SPRING BOOT AND H2 DATABASE
1. This is some kinda embedded database like when you want to create a quick database for your webapp

SCOPE TAG IN POM XML
For example when we say <scope>Runtime</scope> this means that dependency shall only works on runtime

WORK WITH H2DB
1. After injecting dependencies create the sql file
2. Pass in the requirements
3. Write the configurations in the  application properties file
    here the password part is gonna be empty
    spring.jpa.hibernate.ddl-auto=update -> tell that don't delete while updating the columns or database
    spring.h2.console.enabled=true -> this one that we can see the database on the console
    spring.jpa.show-sql=true -> this one so that we can see the executed queries on the console
4. Create the configuration source file if it is needed
5. Then you gonna have to configure the settings coz Spring will deny the page of h2 console as default, after doing
    the configuration in SecurityConfig class you will be good to go.
NOTE: THIS DATABASE IS ALL FOR (POC) WHENEVER YOU RESTART THE SERVER THE DATA WILL ALSO BE GONE


WORKING WITH SPRING JDBC
Note: First create the bean of Datasource -> This one provides the connection of the database
1. Provide the credentials parameters
2. Specify the Sql statement
3. Declare parameters and provide parameter values
4. Do the work for each iteration
5. Use the jdbcTemplate object on each transaction
6. To run the query use the queryForObject() method
    This method takes the query as its first parameter and then the Type.class and then variable if necessary
    Note: we also have some methods such as execute() for ddl and update() for updating
NOTE: All of these are necessary only if you are not building your webApp using SpringBoot coz if you are using it
will handle some of these steps and make your life easier

SPRING JDBC IMPLEMENTATION
1. You have to sync all the data you have mentioned in the sql file to the corresponding pojo class
2. And for the "created" and "updated" fields we gonna have to put them in the different class coz we gonna use the all
    the time we create the schemas so that is why..
3. Create the repository class for the particular corresponding pojo class dont forget the @Repository on it
NOTE: As a developer if you are working with the SpringBoot you don't have to create the Datasource bean or the
    JdbcTemplate bean because the SpringBoot will create for you based on your Application.properties configurations
4. Inside that the repository class write the create the initialize JdbcTemplate class and auto wire it using the
    constructor of class the SpringBoot will handle the rest.
5. Inside that the repository class write the method that will take the data from the particular pojo class this method
    returning value shall be int, and return with the jdbcTemplate with the needed infos from the fields of the pojo.
6. Autowire the Repository inside the corresponding Service class so that you can invoke its methods


ENHANCING THE DASHBOARD
1. We are going to put the page that only admin can see it..
    for that we gonna have to let the UI know about the rule using sec:authorize of the thymeleaf
2. Also we going to put the welcome part in the dash board
    Note: Don't forget to add the corresponding css
3. Then we create a method in the UI corresponding controller class, inside it create a list with will hold the data
    of the particular pojo class with object of the the corresponding service class which there is a method which is
    gonna help us to fetch up the list.
4. Then we gonna add them to the modelView and then we add the attribute then return modelAndView object
5. And also the corresponding service class will also fetch data from the repository class.
6. In the contact repository we create a method to fetch data

** ANY FILE THAT IS GONNA CONTAIN DATA INSERTION MUST BE MAINTAINED INSIDE DATA.SQL

BeanPropertyRowMapper
If the fields inside your pojo class and the fields columns inside your table are exactly matching you can use this
but make sure you create an instance of the rowMapper and mention the class so that in the jdbcTemplate query you will
just pass two parameters

namedParameterJdbcTemplate
This one allow us to use variables instead of putting the question mark on queries and mapping them.. look it up

CREATING AWS CLOUD DATABASE
Simply create an account then go to RDB -> DATABASE -> DATABASE PLATFORM -> FILL THE CONFIGURATION then done.

TO WORK WITH DATABASE
1. After creating the cloud data base from amazon now download the sqlectron app
2. After downloading the app add the database you wanna work with
3. Fill the blanks with the corresponding aws created database
4. On the server address section paste the security link of your aws database
Note: After finish filling the required blanks not all blanks and if you test the connection it won't work because
    the aws database doesn't allow all the address you gonna have to configure that yourself,
5. click the name of the database you wanna work with.. then click inbound rules, add the type and the source and the
    port if it is required, then add rule.. make sure you add all the "everywhere" sources
Note: now if you test the connection again it will be successful
6. Add the dependency of the MySql Driver
7. Add the schema and the data then go to the sqlectron write your queries there and refresh the database to see the
    table if you can not see the table try to reconnect and there you go..
8. Add the data to the table you want like I did to the holidays table I created..

APPLYING THE CHANGES TO THE FRONTEND
1. First if you try to enter to holidays UI where I put we put our data in database you will get some errors like
    css wont display because you must put the the "/" on each "asset/**" tag, another error you will get is
    uncategorized sql exception, to solve this you gonna have to pass the name of the database in the application.
    properties like this "/eazyshool" and after that you might get another error if the query in corresponding repo
    class is uppercase or lowercase


******************************************SPRING DATA JPA********************************************
JPA
1. Is just specification that defines object relation mapping

TO WORK WITH SPRING DATA JPA
1. Create the relation between the pojo class and the database and Spring Data Jpa will handle the queries and to
    do that mention @Entity on the top of the pojo class so that Spring will understand that this class is corresponding
    to a particular database table
2. Add @Table(name="table") and mention the table here
3. Create the relation between columns on the pojo class with the database if and only if they are not matching names
4. Mention the primary key and also tell who is going to generate tha primary key
5. Create interface for the given table entity and extend one of the framework provided by repository interfaces
    Note: inside the extended interface you pass the name of the pojo class and the type of the primary key
6. Enable jpa functionality and scanning by mentioning the required annotation on the spring main class. so that
    Spring will create the beans.

** save() is a crudRepository method which is used for saving and updating the data.

** @mappedSuperClass -> if the class has this annotation then its entities will also be considered as column
@enumerated -> use this if you have any column which is the value is enum

DERIVED QUERY METHODS
These methods helps us to make our own customized queries regards on what we wanna search for..
Note: Spring data Jpa will make query depends on the name of these methods we are creating

AUDITING SUPPORT
Like these 4 columns
 + created_at
 + created_by
 + updated_at
 + updated_by
Note: this are so important details to know whenever we deal with data that is why Spring data give us some annotations
    to work with these columns

WORK WITH AUDITING
1. Give the required annotations to the fields and also this class shall have some annotations and implementations too
2. Create a component class which will get the name of the auditor
3. Enable the configurations in the spring main class

th:href="@{/public/register}" -> This means the link to the register page will be publicly allowed anyone can access it
    and you gonna have to pass the mapping in the corresponding controller class.


SPRING MVC CUSTOM VALIDATORS
1. Build you own custom annotation, mention the pojo that you mention the logic of the customized annotations
    Note: you can follow the built in annotations to create yours on the maven projects jars
2. Implement the ConstraintValidator interface to the pojo class we validate our annotations we created
3. Use the annotation on the top of the fields of the pojo class

@Transient
The field will not be considered with the spring jpa when it comes to database.

UNI DIRECTION AND BI DIRECTION
Uni direction is like only one sided direction for example one to one
Bi direction is a good example of one to many
Note: How does spring know about this, like if you mention the configuration only in one class it will understand
    that, it is uni direction (one to one)

VALIDATIONS USING SPRING SECURITY AND SPRING JPA
Note: This is like when you save the new user to the database then, next time when they wanna log in to the web page
    they are going to authenticated using spring Security and Spring Jpa
1. Tell the spring to enable Spring Security
    Note: This is optional if your are using spring boot
2. Create new bean that will implement authentication provider interface
    Note: here you gonna have to override two method and one of them is authenticate, this method will get the password
    and username and from the ui and then you can do some validations using them. And the second method is support which
    I don't actually know how it works but if this method fail the authenticate method won't even be considered.

** TO CREATE ADMIN JUST TAKE HIS INFO AND ADD HIM PERSONALLY INTO YOUR DATABASE.

HASHING PASSWORDS
1. In projectConfig class create the bean for your preference hashing method

FETCH DATA FROM DB AND DISPLAY ON THE PROFILE WEBPAGE
** After creating all the controller and model classes
1. Create a method which will take the HttpSession object as a parameter
2. Add session session inside the method and there you mention the object of the class which the data base will take
    the data from
3. Access the session object in the method which display the page that is going to display the data from database
4. Get the session using the object of session you accepted with getSession() method into the db object class

SAVING FROM UI TO DB
1. Autowire the corresponding database repository class







