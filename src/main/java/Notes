YOU CAN NOT CREATE A BEAN USING AN INTERFACE ONLY CLASSES.

BEANS WITH XML
1. I had to create xml file manually myself while learning how to create beans using xml file
2. In this section we created the connection with the bean using xml so better check the xml file in resources
3. Here the xml file acts as the Pojo class
3. In the main method we have to use another way of creating object of IoC Container go check it
and there you pass the name of the xml file folder you created

AUTOWIRED
1. Can bu used on top of the setter, constructor or class fields
2. This is an example of Dependency Injection (Dynamic)
3. We initialized the component annotation on top of the pojo classes to make things easier
4. This method is not recommended because you can't initialize a autowired field as final but still most
   developers almost 99% of developers are using this because it is easy to use ..
5. Use this method with annotation on the constructor that's the better way because it allows finals fields

AUTO WIRING DEEP DIVING
1. When we use @autowired with constructor we might have more than one pojo class and we might have more than one
   beans and in case sometimes they might have the same name, which lead us to NoUnique error but as we know we use
   the @primary annotation we might get rid of that error, if we don't have it there are more steps which Spring follows
   to check before giving the error check the codes.

QUALIFIER ANNOTATION
1. We use this annotation when we use @autowired annotation and when we want to get a bean using their name so
   we use this annotation to pass the name.

CIRCULAR DEPENDENCY
1. This happens when a programmer create two @autowired annotation in both two pojo class in that case the Spring
   will not know which bean should be first created and both bean will wait for other bean to be created, and
   such a scenario will display a UnsatisfiedDependencyException, and hey there is no solution for it you gonna
   have to avoid this thing from the beginning hhhh.

5 TYPES OF SCOPE IN BEAN
1. Singleton -> Default Scope in Spring
2. Prototype
3. Request
4. Session
5. Application

RACE CONDITION
This happens when two threads trying to reach the same shared variable

